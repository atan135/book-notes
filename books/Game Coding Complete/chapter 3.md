## Coding Tidbits and Style that Saved Me

> 记住一点，一个问题的解决方案不是非此即彼的，也可能多种方案都是可行的，只是要给选择问题而已，没必要在这上面太多争论。

**通用编程规范：**

1. **大括号**

   作者建议使用严格换行的方式，我的做法是函数内小于5行的代码块，使用K&R的方式，大于5行的代码块，大括号都严格换行写。所有的函数方法的大括号都严格执行换行。例如：

   ```cpp
   // 所有的方法后大括号，都同意换行
   void FunctionA()
   {
       for(int i = 0;i < 5;++i){
           cout << "小于5行的代码块，使用K&R方式" << endl;
       }
       
       if(true)
       {
           int a1;
           int a2;
           int a3;
           cout << "大于等于五行的代码块，使用严格换行方式" << endl;
           return;
       }
       
       return;
   }
   ```

2. **格式一致性**

   作者建议以下三种形式的都可行，但是重点是，在一个工程内的代码，都严格执行这种格式规范。我是使用第一种。对于所有第三方代码，都需要将其放置在单独一个目录内管理，防止和主程序代码混杂。

   ```cpp
   Action* FindBestAction(void);
   Action* findBestAction(void);
   Action* find_best_action(void);
   ```

   此外，对于不同类的相似功能的函数，建议使用相同命名。类似STL中，所有尾插入的容器，都是用push_back插入元素，而对于非尾插入类型容器，如unordered_map，则使用insert插入元素。

**编程技巧**

* **让代码执行的功能就像人们预设的一样，如果有不期望的，可以将其屏蔽，让编译器告知调用者错误。**

  比如让构造函数保持其简洁不报错，让复制函数、相等操作符执行简单的复制、相等比较，对不期望的复制，将其设置为隐藏防止其他人误调用。

* **类继承关系尽量层级少，继承关系明确简洁**

* **正确选择继承和组成（inheritance and composition）**

* **正确处理、使用虚函数**

* **正确使用接口（纯虚函数组成的类）**

* **正确使用工厂模式**

* **封装易变的模块**

* **给需要持久化的对象设置序列化/反序列化方法**

* **在需要的场景使用智能指针（如event system）**

举例：

1. 类似cpp的语言，构造函数内不要包含可能会报错的函数。如初始化文件、初始化管道，初始化网络socket的功能应该放在其他函数中调用。
2. 不要为了未来扩展把所有类成员函数设置为virtual

**tips**

```cpp
//保证编译器不会对struct做字节对齐
#pragma pack(push,1)
//struct 代码
#pragma pack(pop)
```

**实现内存管理的几点**

* 选择最适合此游戏业务的内存数据结构。如果是有大量内存单元，选择使用hash table或者tree 结构，如果不需要去频繁查找空余内存单元，可以使用链表结构；再比如将内存管理和内存池分离，这样内存池的奔溃不会影响内存管理结构。

* 注意该模型是否需要适应多线程场景。
* 在内存单元中保留一些空间用于存储额外信息。在debug代码中至少保留\_\_FILE\_\_和\_\_LINE\_\_的信息，方便查看日志。

**举例**

在vs环境下，连续new两个int值，会发现其地址值差远大于4字节，在debug模式下是60字节，在release模式下是28字节，原因是系统管理的heap中，需要一些额外字节来维持整个内存块结构信息。所以频繁小字节在heap上的生成，最合适的是使用自己管理的内存管理结构。

**内存池管理**

使用的是初始化一系列的内存块，之间使用指针关联成为链表。然后alloc的从链表剔除，free的接入链表，如果空间不够，再另外malloc一块内存，初始化为该结构