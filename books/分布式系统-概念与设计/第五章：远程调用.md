**远程过程调用**

RPC将过程调用的通用编程抽象扩展到分布式环境。一个调用过程可以像调用本地节点上的过程那样去调用一个远程节点的过程。

**远程方法调用**

RMI在分布式系统中使用了面向对象的编程概念，把对象引用扩展到全局分布式环境中，因此在远程调用中可以吧对象引用作为参数。

## 请求应答协议
使用三个通信原语`doOperation`,`getRequest`,`sendReply`完成。

<dl>
<dt>客户端使用doOperation方法调用远程操作</dt>
<dd>方法参数指定远程服务器、带调用的操作以级操作请求的附加信息（参数）。
</dl>
<dl>
<dt>服务端通过getRequest方法获得请求消息</dt>
<dt>服务端通过sendReply方法向客户发送应答消息</dt>
</dl>

#### 请求应答协议的故障模型：

**1. 超时**

超时发生时，doOperation的简单选择是立即返回给客户一个doOperation操作故障的标识。但是这个不是常见的方法。超时的原因又请求或应答消息丢失。对于后者，该操作已经被执行，为了避免消息丢失的可能，doOperation方法会重复的发送请求消息直到它收到应答，或已有理由相信延迟是因为服务器未作应答而不是丢失了请求消息。最终，doOperation方法返回时，会以为接收到结果的异常通知调用客户。

**2. 丢弃重复的请求消息**

当请求消息重复传输时，服务器可能不止一次的接收到该消息，协议设计能识别出带有相同请求标识符的连续信息，过滤掉重发信息。

**3. 丢失应答消息**

当服务器收到一个重复的请求消息时已经发送了应答消息，那么除非它保存了原先执行的结果，否则它需要再次执行这个操作来获得该结果。  **概念：幂等操作**

**4. 历史**

对于要求重新传输应答而不需要重新执行操作的服务器来说，可以使用历史，这指包含已发送的应答消息的记录的结构。

**三种RPC交换协议**

| 名字 | 客户 | 服务器 | 客户     |
| ---- | ---- | ------ | -------- |
| R    | 请求 |        |          |
| RR   | 请求 | 应答   |          |
| RRA  | 请求 | 应答   | 确认应答 |

## HTTP协议使用
**内容协商：** 客户端请求中包含说明他们能够接收的数据表示形式的信息，使服务器能选择出对于客户端最合适的数据表示形式。

**认证：** 试图去访问受保护的资源时，服务器的应答包含了适用于咨询的质询(challenge)，当客户端收到质询，它令用户输入用户名和密码，并提交与后续请求相关联的凭据(credential).

HTTP基于TCP协议，在该协议的最初版本中，由以下步骤组成：

* 客户端请求连接，服务器在一个默认端口或者URL指定端口下接收连接。
* 客户端向服务器发送请求消息。
* 服务端向客户端发送应答。
* 连接断开

在HTTP1.1中，对相同服务器连续多个请求，使用 **持久连接** 减少连接建立、断开的损失。

#### HTTP方法

**GET方法：** 请求在参数中给出的URL对应的资源，如果URL对应数据，那么服务器就会返回URL指定的数据，如果URL对应程序，那么服务器就会运行该程序并把结果返回给客户端。

**HEAD方法：** 请求与GET相同，但是它不反悔任何数据，然而返回与数据相关的所有信息，如最后一次修改时间，数据的格式，大小。

**POST方法：** 指定资源的URL，该资源可以处理在请求消息体中提供的数据。当某个执行活动可能改变服务器数据时，使用POST方法。

**PUT方法：** 要求请求中提供的数据在存储时以指定的URL作为标识符，要么作为现有资源的修改，要么作为一种新资源。

**DELETE方法：** 服务器删除给定URL标识的资源，服务器可能不经常允许该操作，这种情况下返回失败的应答。

**OPTIONS：** 服务器提供给客户端能够应用到给定URL及其特定需求的方法列表。

**TRACE：** 服务器返回请求的消息，用于诊断的目的。

**HTTP请求消息组成**

| 方法 | URL或路径名                     | HTTP版本 | 头部 | 消息体 |
| ---- | ------------------------------- | -------- | ---- | ------ |
| GET  | http://www.baidu.com/index.html | HTTP/1.1 |      |        |


**HTTP应答消息组成**
| HTTP版本 | 状态码 | 理由 | 头部 | 消息体   |
| -------- | ------ | ---- | ---- | -------- |
| HTTP/1.1 | 200    | OK   |      | 资源数据 |

其中消息体自身的头部信息标识了数据信息，如消息体的长度，MIME类型，字符集，内容编码和最后的修改时间。

## 远程过程调用
**接口编程** 大多数现代编程语言提供了把一个程序组织成一系列能彼此通信的模块的方法。模块之间的通信可以依靠模块间的过程调用，或者直接访问另外一个模块中的变量来实现。为了控制模块之间可能的交互，需要为每一个模块定义显式的接口，模块接口指定可供其他模块访问的过程和变量。实现后模块就隐藏了除接口以外的所有信息。只要模块的接口保持相同，模块的实现就可以随意改变而不影响模块的使用者。

**RPC调用语义**

* **或许调用语义：** 远程方法可能执行，也可能不执行。当没有使用任何容错措施的时候，就启用了或许调用语义。可能会出现的故障有
  * 遗漏故障：如果调用或结果消息丢失
  * 系统崩溃：由于包含远程对象的服务器出现故障
* **至少一次调用语义：** 调用者可能收到返回结果，也可能收到一个异常。在收到返回结果的情况下，调用者知道方法至少执行了一次，而异常信息则通知它没有接收到执行结果。可以通过重发请求消息来实现，屏蔽了调用或者消息的遗漏故障。可能出现的故障有：
  * 由于包含远程对象的服务器故障而系统奔溃
  * 随即故障：重发消息时，远程对象可能接收到这一消息并多次执行调用方法，导致存储或者返回了异常值
* **至多一次调用语义：** 调用者可以接收返回结果，也可以接收一个异常。在接受返回结果时，调用者知道恰好执行了一次，而异常信息则通知调用者没有收到执行结果。

**容错措施**

| 重发请求消息 | 过滤重复消息 | 重新执行过程或重传应答 | 调用语义 |
| ------------ | ------------ | ---------------------- | -------- |
| 否           | 不适用       | 不适用                 | 或许     |
| 是           | 否           | 重新执行过程           | 至少一次 |
| 是           | 是           | 重传应答               | 至多一次 |

**样例：SUN RPC**

SUN RPC可以使用基于UDP协议实现，也可以使用基于TCP使用，采用UDP协议时，请求消息和应答消息的长度被限制在一定长度范围内。SUN RPC使用至少调用一次语义。

SUN RPC使用一种称为XDR的接口语言和一个可以用于C编程语言的接口编译器rpcgen

SUN RPC实现细节；

1. 提供一个程序号和一个版本号，用于保证每个程序都有唯一编号。
2. 一个过程定义指定一个过程签名和一个过程号。过程号作为请求消息中的过程标识符。
3. 只允许使用单个输入参数，因此多个参数需要使用结构作为参数的集合。
4. 过程的输出参数是单个结果
5. 过程签名由返回类型，过程名和输入参数类型组成，返回结果和输入参数的类型可以指定为单个的值，也可以指定为包含几个的值的结构。
6. 当一个过程签名改变时，版本号也会随着改变，程序号和版本号都会在消息中传输，以便客户和服务器验证他们是否正在使用相同的版本。

一个典型的SUN RPC接口文件：
    
    const MAX = 1000;
    typedef int FileIdentifier;
    typedef int FilePointer;
    typedef int Length;
    struct Data{
        int length;
        char buffer[MAX];
    };
    struct writeargs{
        FileIdentifier f;
        FilePointer position;
        Data data;
    };
    struct readargs{
        FileIdentifier f;
        FilePointer position;
        Length length;
    };
    
    program FILEREADWRITE{
        version VERSION{
            void WRETE(writeargs)=1;
            DATA READ(readargs)=2;
        }=2;
    }=9999;

接口文件使用rpcgen生成以下部分：

* 客户存根过程
* 服务器main过程，分发器和服务器存根过程
* 用于分发器，客户与服务器存根过程的XDR编码与解码过程

**绑定**

SUN RPC使用一个称为端口映射器的本地绑定工具。里面记录了本地运行的所有服务所使用的程序号、版本号、端口号。当服务器启动时，在端口映射器注册其服务的程序号、版本号和端口号。当客户启动时，发送指定程序的程序号、版本号的远程请求到服务器主机上的端口映射器，从而找到服务的端口。

**认证**

SUN RPC请求和应答消息提供了一些附加域，用于客户与服务器之间的传输认证消息。

## 远程方法调用RMI
**RMI和RPC的共性：**

* 都支持接口编程，同时能带来使用这种方法的好处
* 都是典型的基于请求-应答协议构造的，能提供一些列的调用语义
* 都提供相似程度的透明性。

**RMI在副本是应用中的额外功能：**

* 程序员能够在分布式系统软件开发中使用所有的面向对象编程的功能，包括对象、类、继承的使用以级相关面向对象的设计方法和相关工具的使用。
* 对象引用可以作为参数传递，因此RMI比RPC能提供更多的参数传递语义。

#### RMI的实现

![](http://cdn.zergzerg.cn/distributed_system_RMI.jpg)

**通信模块** 两个相互协作的通信模块执行请求-应答协议，在客户与服务器之间传递请求和应答消息。服务器通信模块为被调用的对象类选择分发器，传递其本地引用。该本地引用取自远程引用模块，用来替换请求消息的远程对象标识符。

**远程引用模块** 远程引用模块负责本地对象引用和远程对象引用之间进行翻译，并负责创建远程对象引用。为履行其职责，每个进程中的远程引用模块都有一个远程对象表，该表记录着该进程的本地对象引用和远程对象引用的对应关系，这张表包括

* 该进程拥有的所有远程对象
* 每个本地代理

**伺服器** 提供了远程对象主体的类的实例。由相应骨架传递的远程请求最终是由伺服器来处理的。

**RMI软件** 位于应用层对象和通信模块、远程引用模块之间的软件层组成。有几种角色：

* 代理
* 分发器
* 骨架



## Q & A

**1. 定义一个类，实例代表了请求消息和应答消息，该类需要提供一堆数据结构，分别为了完成请求和应答消息。说明请求标识符是如何分配的，需要提供一个方法能够将自己编码进一个字节数据并且能够解码一个字节数组到实例中。**

```cpp
class T{
    unsigned int m_requestId;
    Identity m_netAddress;
    ParamArgs m_args;
    ErrorCode SerializeToBytes(byte[] result);
    ErrorCode ParseFromBytes(byte[] input);
}
```

标识符分配规则通过将互联网地址和进程监听端口号的组合值作为标识符，这个在分布式系统中是唯一的，然后requestId由进程使用自增序号，保证消息的唯一性。

**2. 使用UDP通信编写一个请求-应答协议的三个操作程序，但是不要添加任何的容错措施**

就是封装处理，client send操作封装为doOperation，server receiv操作封装为getRequest，server send操作封装为sendReply。

**3. 给出服务器实现的要点，说明在一个通过创建新县城来执行每个客户端请求消息的服务器中，如何使用getRequest操作和sendReply操作。说明服务器是如何从请求消息中复制requestId到应答消息中，以及它如何获取客户端的IP地址和端口号的。**

服务器通过getRequest方法获得请求消息，当服务器调用了指定的操作时，就会通过sendReply方法向客户发送应答消息。当客户收到应答消息后，doOperation阻塞解除，继续执行。服务器解析了请求消息，可以获取客户端的requestId，直接用于应答消息的requestId赋值即可。客户端的IP地址和端口号在底层协议包如UDP和TCP内即可获得。

**4. 定义一个新的doOperation方法，该方法在等待应答消息时可以设置超时，当超时完成后，重新发送请求消息n次，如果仍然没有应答，会通知访问者。**

使用while不断检测在超时时间之前有没有收到应答回复。如果没有，则重新发送请求。如此操作n次后，没有获得结果即通知调用方错误码。

**5. 描述客户端能接收到一个针对更早调用的应答的场景**

客户端发送请求后由于网络延迟，服务端在较晚时间才收到回复，然后客户端在未收到应答时使用了重新发送，在收到第一份请求应答后，继续执行，然后收到第二次请求的应答。

**6. 描述一种方法使请求应答协议能够屏蔽操作系统的不同和计算机网络的异构**

基于一致的标准，如通用TCP、UDP协议，统一使用网络序对通信消息字节排序，通信消息的数据结构一致。

**7. 讨论下面的操作是否是幂等的：**

* 按电梯的按钮----------------------------是的
* 向文件写入数据-------------------------是的
* 向文件追加数据-------------------------不是

操作不应该伴有任何状态的变化是成为幂等操作的条件么？不是的，幂等操作只要符合两次相同请求执行结果的效果和一次执行是一致的即可。

**8. 从最小化服务器端所拥有的应答数据数量的角度解释设计的选择方案，比较使用RR和RRA协议时的存储需求**

最小化服务器端，应该使用RR协议，因为这个不需要特殊的确认消息，不需要保留数据用于重传，简化了服务器端的设计复杂度。也减少了对未确认消息保存的存储需求。但是为了保证消息的可靠性，使用了重复发送机制，需要保证操作的幂等性，不会因为重新操作导致数据执行出错。

**9. 假设使用RRA协议，服务器应该保留未被确认的应答消息多久？为了接收到确认，服务器端应该重新发送应答吗？**

为了保证通信协议的可靠性，需要永久保持着，直至收到客户端的确认或者requetId比已保留消息的最大requestId序号更大。服务器端不执行主动重发操作，由客户端根据自己获得结果使用重发或者发起新请求。

**10. 为何在协议中交换的消息的数量比发送的数据总量对性能来说更有意义， 设计RRA协议的一个变种，在该变种协议中，当要传输的下一个请求消息出现时，在同一个请求消息中捎带发送确认消息，否则发送单独的确认消息**

因为也需要考虑重传、确认等消息，考虑交换的总消息数据量更有意义。（第二问是客户端使用额外的计时器，没理解）

**11. Election接口提供两个远程方法：vote：带有两个参数，客户通过这两个参数提供一个候选者名字和投票者编号（用于确保每个用户刚好只投票一次的整数）。投票者编号在整数范围内随机选择，以便不会被猜出来；result：带有两个参数，服务器通过这两个参数给客户提供候选者的名字和候选者的投票编号。**

这两个过程，vote是输入型参数，result是输出型参数。

**12. 讨论在TCP/IP连接上实现请求-应答协议的时候可以获得的调用语义，该语义要确保消息的按发送序列到达，既不丢失数据也不复制数据，考虑导致连接中断的所有条件。**

可以获得最多一次调用语义。TCP协议保证了消息的有序接收，通过ACK机制保证了消息到达的可靠性。连接中断可能是网络中断、网络延迟超过TCP的重传时间限制、服务器崩溃。

**13. 以COBAR和JAVA的IDL定义Election服务的接口，注意，CORBA提供32位的整数类型long，比较这两种语言中指定输入型和输出型参数的方法**

```
struct VoteArgs{
    string name;
    long id;
};
struct ResultArgs{
    string name;
    long id;
};
interface Election{
    void getResult(out ResultArgs result);
    void sendVote(in VoteArgs vote);
}
```

**14. Election服务必须确保每次用户想投票时，选票就被记录下来。讨论在Election服务上使用或许调用语义的效果，至少一次调用语义可以接受么？应该使用至多一次调用语义么**

使用或许语义，可能会出现提交vote服务端没有处理的情况，导致假投票 的发生。至少一次调用语义是可以接受的，只要服务端做好处理，限制好每个用户最多投票一次的限制，就可以保证操作的幂等性，使用至少一次调用语义即可保证操作的必然处理。

**15. 在一种带有遗漏故障的通信服务上实现请求-应答协议，以提供至少一次的RMI调用，在第一种情形中，实现者假设一个异构的分布式系统。在第二种情形中，实现者假设通信和远程方法执行的最大时间是T。用哪种方法能简化后者的实现。**

通过处理设置合适的重传时间间隔。

**16. 在Election服务中，要确保在多个客户并发访问时，选举记录能保持一致，简述其如何实现**

服务端使用版本号确定每次操作的唯一性，客户端会记录服务器的最新版本号，获取最新的选举记录。

**17. Election服务必须确保安全地存储所有的选票，即使服务器进程崩溃也如此，如何实现**

使用持久对象存储，将这些记录存入磁盘或者数据库。

**18. 如何曹勇Java反射构造Election接口的客户代理类，给出该类中一个方法的实现细节，他应该用一下基调调用doOpertioan方法：`byte[] doOperation(RemoteObjectRef o, Method m, byte[] args)`**

java不是很熟。。。

**19. 解释如何根据CORBA接口定义使用像c++这种不支持反射的语言，生成一个客户代理类。给出该类中一个方法实现的细节，应该调用定义的doOperation方法**

使用map，预编译所有方法，使每个字符串对应一个函数指针。

**20. 解释如何使用Java反射构造一个通用的分发器，给出具有下列基调的分发器的Java代码：`public void dispatch( Object input, Method aMethod, byte[] args)`**

Java反射包中的Method类的实例能够通过invoke方法被一个和合适的类对象调用，调用方法需要两个参数：第一个参数指定接受调用的对象，第二个参数是一个包含参数的Object数据，结果作为Object类型返回。对于使用代理、分发器的方法，代理必须把方法和参数信息编码到请求信息中，对于方法，代理编码成为Method类的一个对象，把参数放入一个Objects数组中，然后编码该数组。分发器从请求消息中解码信息得到Method对象和它在Objects数组的参数，通常，目标对象的远程引用以及被解码，对应的本地对象引用已从远程对象引用模块获得，然后，分发器用目标对象和参数值数组调用Method对象的invoke方法，执行方法后，分发器将结果或者出现的异常编码到reply消息中，这样，分发器是通用的。

**21. 讨论如下doOperation的实现，`Object[] doOperation (RemoteObjectRef 0, Method m, Object[] args);`**

上题已回复。

**22. 一个客户向服务器发出远程过程调用，客户花5ms时间计算每个请求的参数，服务器花10ms时间处理每一个请求。本地操作系统每次发送和接收操作的时间是0.5ms，网络传递每个请求或者应答的时间是3ms，编码或者解码每个消息花费0.5ms。那么计算如下情况所花费的时间**

* 如果它是单线程的
* 如果是有两个线程，能够在一个处理器上并发的发出请求

**如果客户和服务器处理器是线程化的，那么需要使用异步RPC么？**

单线程：所有时间各一次加起来。两个线程：操作系统发送和接收时间2倍，其余不变。不需要使用异步RPC。

**23. 设计一个支持分布式无用单元收集和在本地对象引用与远程对象引用之间转化的远程对象表。给出一个例子，设计在不同地址上的几个远程对象和代理，以说明该表的作用。给出当调用导致船舰新代理时表的变化，给出当一个代理不可用时表的变化**

当一个远程对象引用进入一个进程，进程就会创建一个代理，只要需要这个代理，它就会一直存在，对象生存的进程应该高知给客户上的新代理，随后当客户不再有代理时，也应高知服务器。分布式无用单元收集器和本地无用单元收集器的协作方式如下：

* 每个服务器进程为它的每个远程对象维护拥有远程对象引用的一组进程名。服务器维护一个具有对象的代理的客户进程的集合holder。
* 当客户第一次接收到远程对象的远程引用时，发出一个addRef调用到远程对象的服务器并创建一个代理，服务器将客户添加进入代理的客户进程集合表中。
* 当客户的无用单元收集器注意到远程对象的一个代理不可达时，发出一个removeRef的调用到相应的服务器，然后删除该代理，服务器从holder表删除客户。
* 如果服务器不存在本地持有者，当holders为空时，服务器的本地无用单元收集器将回收被服务占用的空间。

**24. 上题描述了分布式无用单元收集算法的一个简单版本，该算法在每次创建一个新的代理时，就会调用远程对象所在地的addRef，每次删除一个代理，就会removeRef，概述算法中通信故障和进程故障可能造成的影响，提出解决每种影响的建议，但是不能使用租借（不会。。看到的方法是使用了租借）**

* 通信故障：由于addRef和removeRef是幂等操作，当addRef调用返回一个异常（意味着可能操作执行过一次，可能没有执行）时，客户不会创建代理，而是发出一个removeRef调用，removeRef的效果是否正确取决于addRef是否成功。removeRef的失败通过租借来处理。
* 客户进程故障：服务器将对象租借给客户一段时间，租借期从客户给服务器发出addRef开始，到过期时间后终止，或者客户给服务器发出一个removeRef调用后终止。

自己不使用租借，就只能自己去设置一个定时器，模拟租借的功能，在优先时长内处理，超时后没有收到客户端续约即自己调用removeRef操作。