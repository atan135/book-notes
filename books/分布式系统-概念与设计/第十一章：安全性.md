密码学是保证消息的私密性和完整性以及消息认证的基础。加密算法的选择和密钥的管理是安全机制的效率、性能和可用性的关键。

* **公钥加密算法：** 分发密钥比较容易，但是对大数据量的加密性能较差
* **密钥加密算法：** 更适合大批的加密任务
* **混合型加密协议：** 例如TLS，先用公钥加密建立一个安全通道，然后使用通道交换密钥，并将此密钥用于后续数据交换。

## 对分布式系统攻击的分类：

* **窃听：** 未经授权获得消息副本
* **伪装：** 在未经授权的情况下，用其他主体的身份收发消息
* **消息篡改：** 在将消息传递给接收者之前，截获并修改消息的内容
* **重发：** 存储截获的消息，并稍后发送它们。这种攻击对已认证的消息和加密消息仍然有效
* **拒绝服务：** 用大量的消息使通道或者其他资源瘫痪，使得其他访问被拒绝

## 密码学的三种应用形式：

**一、共享密钥通信：**

用于简单的A发送消息给B，两者共用一个密钥K~AB~ 。

1. A使用K~AB~ 对消息M加密，使用两者协商好的加密算法，将加密后的消息发送给B
2. B使用K~AB~ 对消息M进行解密

可能存在的问题：

1. 密钥K~AB~ 怎么在A,B之间传递
2. 怎样防止消息被别人截获后重发

**二、与服务器的认证通信：**

用于A通过认证服务器S访问B的资源时候使用。由S颁发Ticket用于A,B之间的通信。

1. A向S发送一条未加密的消息，内容声明自己的身份，并向S请求一个访问B的ticket
2. S用K~A~ 加密应答消息，并回发给A。应答消息包括一个用K~B~ 加密的ticket，和一个新的密钥K~AB~ ，即形式为 $$\{\{ticket\}_{KB} , K_{AB}\}_{KA}$$
3. A使用K~A~ 解密应答消息，取得ticket以及K~AB~
4. A将ticket，自己的身份以及一个请求参数R一起发送给B，即 $$\{ticket\}_{KB}, A, R$$
5. ticket的生成实际上是 $$\{K_{AB}, A\}_{KB}$$ ,B使用自己的密钥K~B~ 解密ticket，便也得到了用于A，B之间通信的密钥K~AB~ 

**三、使用公钥的认证通信：**

用于B已经产生了一个公钥/密钥对，通过如下方式使得A，B可以共享密钥K~AB~ ，这种方式称为混合密码协议

1. A 访问一个密钥分发服务得到公钥证书，它给出了B的公钥。之所以称为证书，是因为它是有一个可信的权威机构签发的。在检验过签名后，A从证书中读取B的公钥K~Bpub~
2. A 创建一个与B之后小心通讯的共享密钥K~AB~ ,并用公钥算法和K~Bpub~ 对新密钥K~AB~ 进行加密，将结果和一个能唯一表示公钥/密钥对的名字发给B（因为B可能有多个公钥/密钥对）
3. B从他的众多密钥中选出对应的私钥K~Bpriv~, 并用这个解密消息，获得共享密钥K~AB~

**四、使用安全摘要函数的数字签名：**

用于向第三方核实消息或者文档在签名人完成后没有被改变过。

1. A为文件计算出一个固定长度的摘要 $$\operatorname{Digest} (M)$$
2. A用它的私钥K~Apriv~ 为这个摘要加密，并附在M上，再将 $$M,\{ \operatorname{Digest}(M)\}_{KApriv}$$ 公布给需要的用户
3. B得到了这个含有签名的文件，抽取出M并计算 $$\operatorname{Digest} (M)$$
4. B用A的公钥K~Apub~ 解密数字签名，如果结果与自己计算的一致，说明没有被篡改过

**五、数字证书的使用：**

用于一个主体签发的包含一个声明的文档证书，例如B是一家银行，当其顾客需要与他建立联系的时候，它们需要确认它们是在和银行B交互，即使它们从前从来没有与B接触过。B则在授予用户访问它们的账号的权限之前，对其身份验证。

1. A获得由B颁发的数字证书，使用K~Bpriv~ 加密
2. A通过C完成交易时，C需要校验A的证书的有效性，于是先需要获取B的公钥
3. C从某权威机构获得B的公钥的证书，这之间可能重复2的步骤向上递归，直至最终的权威机构认证
4. 这样就形成了一个证书链，由于私钥有被泄露的危险，以及证书链可容许的长度会引发其他问题，因此证书链越长，安全风险越大

数字证书如何取消：证书会有一个有效时间，如果过期了，就不会被权威机构信任。原因是直接撤销，需要删除所有保留该证书的拷贝，实现的开销巨大。

## 加密算法

**一、对称加密：**

加密密钥和解密密钥相同，暴力破解的难度取决于密钥K的长度比特值，呈指数级递增

**二、不对称加密：**

所有公约方案的基础是陷门函数，即一个有秘密出口的单向函数，从一个方向上计算很容易，但是在不知道密钥的情况下，则几乎不可能求其逆。不对称加密所使用的密钥是从一个公共根导出的，在RSA中，需要将两个大素数相乘，然后通过乘积N想反推这两个大素数，是很困难的。加密函数将数据分块为二进制数，使用密钥作为指数，对其做求幂运算，结果对N取模，结果值就是对应的密文。

**三、块密码：**

**密码块链接：** 在密码块链接模式中，每个明文块在加密前和前面的密文块进行异或操作，解密时，块先被解密，再和前面的密文块做XOR操作，从而得到原先的明文。也叫CBC处理。目的是为了防止相同的密码块加密后在密文中显示是相同的。而为了防止向多个目的地建立的数据加密传输也相同，在每个消息的前面加一段不同的明文，这个就是初始化向量。它强制每个消息都以不同的明文块开头。这样和CBC结合，可以保证即使是相同的明文，也可以转化为不同的密文。

使用CBC模式，必须保证加密数据在可靠的连接上传输，任意密文块的丢失都会导致解密失败。

**四、流密码：**

实时的数据流加密，使用流密码，是一种增量式加密的加密算法。

方法是通过构造一个密钥流生成器，密钥流是一个任意长度的比特序列，通过将其和数据流做XOR操作，即可完成加密的过程。如果这个密钥流是安全的，那么得到的加密数据流也是安全的。

密钥流产生器是通过对某个范围的输入值重复的应用一个数学函数，得到一个连续的输出值流而得到的。然后将输出流连接起来组成明文块，再将这些块以双方共享的密钥加密，密钥流还可以使用CBC伪装，范围输入值可以通过一个随机数生成器生成起始值。

**总结：**

所有的加密算法都是基于信息论的，包含了两个基本原则：**含混和扩散**，（confusion and diffusion）。用于隐藏密码块中的内容，通过将内容与一个足够大的密钥K相组合，来对付强行攻击。

* **含混：** 使用非破坏性的操作，如XOR和循环移位将明文块与密钥结合，产生一种新的位模式。从而隐藏M和{M}~k~ 的关系，如果一个块有多个特征，那么可以抵抗基于特征频率知识的分析。
* **扩散：** 通过对每个明文块调换位置来消除规律性模式，如果使用CBC，稍长的正文依然会产生冗余。



## 加密算法具体实现

### 对称加密

**一、TEA：**

```cpp
void encrypt(unsigned long k[], unsigned long text[]){
    unsigned long y = text[0], z = text[1];
    unsigned long delta = 0x9e3779b9, sum = 0; int n;
    for(n = 0;n < 32;n++){
        sum += delta;
        y += ((z<<4) + k[0])^(z+sum)^((z>>5)+k[1]);
        z += ((y<<4) + k[2])^(y+sum)^((y>>5)+k[3]);
    }
    text[0] = y; text[1] = z;
}
void decrypt(unsigned long k[], unsigned long text[]){
    unsigned long y = text[0], z = text[1];
    unsigned long delta = 0x9e3779b9, sum = delta << 5;int n;
    for(n = 0;n < 32; ++n){
        z -= ((y<<4)+k[2])^(y+sum)^((y>>5)+k[3]);
        y -= ((z<<4)+k[0])^(z+sum)^((z>>5)+k[1]);
        sum -= delta;
    }
    text[0] = y;text[1] = z;
}
```

这个算法提供了一个安全、合理、快速的密钥加密算法，比DES算法更快，程序的间接性也有助于优化和硬件实现，128比特的密钥足够应付强行攻击。

**二、DES：**

使用56比特的密钥将64比特的明文映射称为64比特的密文。目前也已经被破解了。

**三、IDEA：**

使用128比特的密钥加密64比特的块，主要基于群代数，使用XOR，模2^16^ 的加法和乘法处理。

**四、RC4：**

流密码，密码长度不超过256字节，加密解密速度是DES的10倍，但是后来发现算法有缺陷，能够被破解。

**五、AES：**

当前常用的加密方式，使用Rijndael算法。

### 非对称加密

**一、RSA：**

基本思想是分解大整数的素因子的计算是非常困难的，不可能有效的计算出来。找出RSA的密钥对 $$<e, d>$$ 步骤如下：

1. 选择两个大素数，P 和 Q （每个数都是大于10^200^ 的），并且计算：

   ​	$$N = P \times Q$$

   ​	$$Z = (P-1) \times (Q-1)$$

2. 对于d , 选择任意与 Z 互质的数

3. 找出e，求下列等式：

   ​	$$e \times d = 1 \mod Z$$

   找出满足上式的最小的e的取值，这样找出了密钥对 $$<e, d>$$ ，然后将明文分为长度k比特的块，其中2k < N，也就是说一个块的数字值总是小于N。

4. 加密明文M中的一个块的函数是：

   ​	$$E'(e, N, M) = M^e \mod N$$

   而将密文解密成为明文块的函数为：

   ​	$$D'(d, N, c) = c^d \mod N$$

   在这里，上式两个操作是可逆的，即 $$E'(D'(x)) = D'(E'(x)) = x$$

   参数e, N可以看作是加密函数的密钥，d，N可以看作是解密函数的密钥，于是，可以表示为 

   ​	$$K_e = <e, N>\qquad K_d = <d, N>$$

**二、椭圆曲线算法：**

有兴趣的可以去搜索下。

## 安全摘要函数

安全摘要函数主要用来刻划消息的较短的，定长的散列值，一个安全的安全摘要函数 $$h = H(M)$$ 一般需要具有以下性质：

* 给定M，很容易计算出h
* 给定h，很难推出M
* 给定M，很难找到其他的M'，使得 $$H(M) = H(M')$$

这样的函数也称为单向散列函数。（了解**生日攻击、生日悖论：** 随机寻找某一个匹配的难度要远远大于随机得到两个相同匹配的难度）

**MD5：**

MD5算法共有四轮操作，源文本以512比特为一块，每一块又划分为16个32比特的字段，每轮对一个段应用四个非线性函数中的一个，结果产生一个128比特的摘要，MD5是当前可用的最高效的算法之一。

**SHA-1：**

是一个产生160比特摘要的算法，基于MD4算法，并附加了一些额外的操作，使得运行速度比MD5慢很多，但是摘要更长，更能提供安全保障。

**使用对称加密算法生成摘要：**

通过对称加密算法生成一个安全摘要，然后将密钥发不出去，让任何希望验证数字签名的人可以运用摘要算法进行有关的验证。加密算法用于CBC模式，其摘要是倒数第二个CBC值和最终加密快的组合结果。

## 安全套接字（TLS）

TLS由TLS记录层和握手层两部分组成，其中TLS记录层实现了一个安全通道，用来加密和认证通过任何面向连接的协议传输的消息。握手层包含了TLS握手协议和两个其他相关协议，它在客户和服务器之间建立并维护一个TLS会话。

**TLS握手协议：**

```sequence
title: TLS握手协议实现过程
participant client
participant server
note over client, server: 建立协议版本、会话ID、密码组、压缩方法、交换随机值
client->server: 客户呼叫
server->client: 服务器呼叫
note over client, server: 可选择地发送服务器证书、请求客户端证书
server->client: 服务器自身证书
server->client: 客户端证书请求
server->client: 服务器呼叫完成
note over client, server: 如有请求，则返回客户证书应答
client->server: 客户端证书
client->server: 证书验证
note over client, server: 改变密码组，结束握手
client->server: 改变密码规范
client->server: 结束
server->client: 改变密码规范
server->client: 结束
```

一个要传输的消息首先倍分割成便于处理的块，然后有选择的压缩这些块，加密和消息认证码（MAC）转换部署了经协商后的密码组中指定的算法，最后通过相关的TCP连接将签名和加密后的数据块传送给另一方，接收方执行逆向转换，生成原始数据块。

