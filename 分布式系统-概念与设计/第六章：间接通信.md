间接通信的本质是一个中介者通信，因此不存在发送者和一个或多个接收者之间的直接耦合，本章节讨论问题涉及：

* 组通信：在组通信中，通信通过一个抽象的组进行，发送者并不知道接收者的身份。
* 发布-订阅系统：代表一类方法，这类方法的共同特点是通过中介者将事件分发给多个接收者。
* 消息队列系统：其中消息发送到队列中，接收者从这些队列提取消息
* 基于共享内存的方法，包括分布式共享内存和元祖空间两种方法，给编程人员提供一个抽象的基于全局共享内存抽象。

> **在计算机科学中，所有问题都可以通过某个层次上的间接方式来解决**

**时间解耦：** 发送者不知道也不需要知道接收者的身份，反之亦然，因为空间解耦使得系统开发者有很大的自由度去处理改变，参与者可以被替换、更新、复制、迁移。

**空间解耦：** 发送者和接收者有独立的生命周期，不需要同时存在才能通信，发送者和接收者可以随时的进入和离开。

|          | 时间耦合                                                     | 时间解耦                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 空间耦合 | **性质：** 与一个或一些给定的接收者直接通信；接收者必须在那个时候存在<br/>**例子：** 消息传递、远程调用 | **性质：** 与一个或一些给定的接收者直接通信，发送者和接收者可以有各自的生命周期<br/>**例子：** 参见习题3 |
|空间解耦|**性质：** 发送者不需要知道接收者的身份，接收者必须当时存在<br/>**例子：** IP组播|**性质：** 发送者不需要知道接收者的身份，发送者和接收者有各自的生命周期<br/>**例子：** 下文的大多数间接通信泛型 |

## 组通信

组通信是对组播通信的抽象，可以通过IP组播或者一个等价的覆盖网络实现。

组通信的一个重要特征是一个进程事项直发器一个组播操作，它将消息发送到一组进程中的每一个，而不是发起多个发送操作到每一个进程。

**进程组**

* 消息被传递到进程中，没有进一步提供对分发的支持
* 消息通常是非结构化的字节数组，不支持对复杂数据类型的编码

**对象组：** 一个对象组是一组对象的集合，这些对象并发的处理同一组调用，然后，各自返回其响应。客户对象不需要知道拷贝，他们调用一个本地对象上的操作，该对象充当组的代理。代理使用组通信系统对对象组的成员发送调用。对象参数和结果如在RMI中一样被编码，相关的调用被自动分发到正确的目标对象/方法上。

## 发布-订阅系统

**发布者**发布结构化的事件到事件服务，**订阅者**通过订阅表达对特定事件感兴趣。发布-订阅系统的任务是吧订阅与发布的事件进行匹配，保证**事件通知**的正确传递。

发布-订阅系统的特征：

* **异构性：** 当事件通知被用作一种通信手段时，分布式系统没有被设计实现互操作的组件可以在一起工作。需要的知识生成事件的对象发布它们提供的事件的类型，其他对象订阅事件模式，并提供一个可以用于接收和处理结果通知的接口。
* **异步性：** 通知是由生成事件的发布者异步地发送到所有对其感兴趣的订阅者的，防止发布者需要与订阅者同步，获得了发布者与订阅者的解耦。

发布-订阅系统的模式：

* **基于渠道：** 发布者发布事件到命名的渠道，订阅者订阅其中一个已命名的渠道，并接收所有发送到那个渠道的事件。
* **基于主题：** 通知被声明为一个层级关系的域结构的从属关系，主题作为其中一个域被显示声明，通过层次化组织主题，可以增强基于主题的方法的表达能力。
* **基于内容：** 是基于主题方法的一般化，允许订阅表达式具有一个事件通知上的多个域，更具体来说，基于内容的过滤器是用事件属性值的约束组合定义的查询。
* **基于类型：** 订阅根据事件类型来定义，匹配根据给定的过滤器的类型或者子类型来定义。
* **基于对象：** 允许一个对象对另一个对象发生的改变做出反应。
* **基于概念：** 过滤器可以根据事件的语义和语法进行表述，更具体来说，数据项有一个相关联的语义上下文，该上下文表达了对这些项的意义，这种方式允许对数据项进行解释并翻译成不同的数据格式，从而解决异构性问题。

#### 发布订阅系统的实现

* **集中式实现：** 单节点作为事件代理服务器，发布者发布事件到该代理，订阅者发送订阅到代理并接收返回的通知。与代理的交互通过一系列点对点的消息传输，可以使用消息传递或者远程调用实现。
* **代理网络：** 使用代理网络代替集中式实现，增强系统的弹性、可伸缩性。
* **对等方式实现：** 在这种实现中，发布者，订阅者和代理之间没有区别，所有节点都是代理，它们的合作实现所需的事件路由功能。

![](http://p9zl5r4hu.bkt.clouddn.com/publish_subscribe_arch.png)

**事件路由的集中方式**

* **泛洪：** 向网络中的所有节点发送事件通知，在订阅者端执行适当的匹配。泛洪可以利用底层广播或者组播设施完成，另外，代理被安排在无环图中，其中，每一个代理都可以把事件转发给所有邻居，这种实现方式简单，但是网络流量会冗余。

* **过滤：** 在代理网络中使用过滤，代理通过一个有路径到达有效订阅者的网络转发通知。算法如下

  ```fortran
  upon receive publish(event e) from node x
  	matchlist := match(e, subscriptions)
  	send notify(e) to matchlist
  	fwdlist = match(e, routing)
  	send publish(e) to fwdlist - x;
  	
  upon receive subscribe(subscription s) from node x
  	if x is client then
  		add x to subscriptions;
  	else add(x,s) to routing;
  	send subscribe(s) to neighbours - x;
  ```

  在这里，每个节点维护一个邻居列表(neighbours)，该列表包含了该节点在代理网络中所有相连接的邻居，一个订阅列表(subscriptions)，该列表包含了由该节点位置服务的所有直接连接的订阅者，以及一个路由表。

* **汇聚：** 将事件集合看作是一个事件空间，并且将事件空间的责任划分到网络中的代理集合上。

* **广告：** 在有广告的系统中，通过与订阅传播类似的方式向订阅者传播广告，减少流量负担。

* **知情闲聊：** *informed gossip* ，比较高深了。

## 消息队列

消息队列提供的编程模型很简单，提供了在分布式系统中通过队列进行通信的一种方式，游戏是，生产者进程发送消息到特定队列，消费者进程从该队列中接受消息。通常支持三种接收方式：

* **阻塞接收：** 保持阻塞直至有合适的消息可用为止
* **非阻塞接收：** 轮询操作，检查队列的状态，返回可用消息，或者一个不可用的指示
* **通知操作：** 挡在相关队列中有一条消息可用时，会发出一个事件通知

消息队列可以是FIFO，也可以支持优先级概念，一条消息通常由目的地，与消息相关的元数据（包括消息的优先级、传递模式等字段）和消息体组成。

消息队列系统的一个重要特性是消息是持久的————也就是说，消息队列会无限期存储消息，直至它们被消费为止，并将消息提交到磁盘，以实现可靠传递。消息队列系统也支持一些其他功能，如事务性、消息转换、安全性等功能。

