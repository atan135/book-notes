间接通信的本质是一个中介者通信，因此不存在发送者和一个或多个接收者之间的直接耦合，本章节讨论问题涉及：

* 组通信：在组通信中，通信通过一个抽象的组进行，发送者并不知道接收者的身份。
* 发布-订阅系统：代表一类方法，这类方法的共同特点是通过中介者将事件分发给多个接收者。
* 消息队列系统：其中消息发送到队列中，接收者从这些队列提取消息
* 基于共享内存的方法，包括分布式共享内存和元组空间两种方法，给编程人员提供一个抽象的基于全局共享内存抽象。

> **在计算机科学中，所有问题都可以通过某个层次上的间接方式来解决**

**时间解耦：** 发送者不知道也不需要知道接收者的身份，反之亦然，因为空间解耦使得系统开发者有很大的自由度去处理改变，参与者可以被替换、更新、复制、迁移。

**空间解耦：** 发送者和接收者有独立的生命周期，不需要同时存在才能通信，发送者和接收者可以随时的进入和离开。

|          | 时间耦合                                                     | 时间解耦                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 空间耦合 | **性质：** 与一个或一些给定的接收者直接通信；接收者必须在那个时候存在<br/>**例子：** 消息传递、远程调用 | **性质：** 与一个或一些给定的接收者直接通信，发送者和接收者可以有各自的生命周期<br/>**例子：** 参见习题3 |
|空间解耦|**性质：** 发送者不需要知道接收者的身份，接收者必须当时存在<br/>**例子：** IP组播|**性质：** 发送者不需要知道接收者的身份，发送者和接收者有各自的生命周期<br/>**例子：** 下文的大多数间接通信泛型 |

## 组通信

组通信是对组播通信的抽象，可以通过IP组播或者一个等价的覆盖网络实现。

组通信的一个重要特征是一个进程事项直发器一个组播操作，它将消息发送到一组进程中的每一个，而不是发起多个发送操作到每一个进程。

**进程组**

* 消息被传递到进程中，没有进一步提供对分发的支持
* 消息通常是非结构化的字节数组，不支持对复杂数据类型的编码

**对象组：** 一个对象组是一组对象的集合，这些对象并发的处理同一组调用，然后，各自返回其响应。客户对象不需要知道拷贝，他们调用一个本地对象上的操作，该对象充当组的代理。代理使用组通信系统对对象组的成员发送调用。对象参数和结果如在RMI中一样被编码，相关的调用被自动分发到正确的目标对象/方法上。

## 发布-订阅系统

**发布者**发布结构化的事件到事件服务，**订阅者**通过订阅表达对特定事件感兴趣。发布-订阅系统的任务是吧订阅与发布的事件进行匹配，保证**事件通知**的正确传递。

发布-订阅系统的特征：

* **异构性：** 当事件通知被用作一种通信手段时，分布式系统没有被设计实现互操作的组件可以在一起工作。需要的知识生成事件的对象发布它们提供的事件的类型，其他对象订阅事件模式，并提供一个可以用于接收和处理结果通知的接口。
* **异步性：** 通知是由生成事件的发布者异步地发送到所有对其感兴趣的订阅者的，防止发布者需要与订阅者同步，获得了发布者与订阅者的解耦。

发布-订阅系统的模式：

* **基于渠道：** 发布者发布事件到命名的渠道，订阅者订阅其中一个已命名的渠道，并接收所有发送到那个渠道的事件。
* **基于主题：** 通知被声明为一个层级关系的域结构的从属关系，主题作为其中一个域被显示声明，通过层次化组织主题，可以增强基于主题的方法的表达能力。
* **基于内容：** 是基于主题方法的一般化，允许订阅表达式具有一个事件通知上的多个域，更具体来说，基于内容的过滤器是用事件属性值的约束组合定义的查询。
* **基于类型：** 订阅根据事件类型来定义，匹配根据给定的过滤器的类型或者子类型来定义。
* **基于对象：** 允许一个对象对另一个对象发生的改变做出反应。
* **基于概念：** 过滤器可以根据事件的语义和语法进行表述，更具体来说，数据项有一个相关联的语义上下文，该上下文表达了对这些项的意义，这种方式允许对数据项进行解释并翻译成不同的数据格式，从而解决异构性问题。

#### 发布订阅系统的实现

* **集中式实现：** 单节点作为事件代理服务器，发布者发布事件到该代理，订阅者发送订阅到代理并接收返回的通知。与代理的交互通过一系列点对点的消息传输，可以使用消息传递或者远程调用实现。
* **代理网络：** 使用代理网络代替集中式实现，增强系统的弹性、可伸缩性。
* **对等方式实现：** 在这种实现中，发布者，订阅者和代理之间没有区别，所有节点都是代理，它们的合作实现所需的事件路由功能。

![](http://p9zl5r4hu.bkt.clouddn.com/publish_subscribe_arch.png)

**事件路由的集中方式**

* **泛洪：** 向网络中的所有节点发送事件通知，在订阅者端执行适当的匹配。泛洪可以利用底层广播或者组播设施完成，另外，代理被安排在无环图中，其中，每一个代理都可以把事件转发给所有邻居，这种实现方式简单，但是网络流量会冗余。

* **过滤：** 在代理网络中使用过滤，代理通过一个有路径到达有效订阅者的网络转发通知。算法如下

  ```fortran
  upon receive publish(event e) from node x
  	matchlist := match(e, subscriptions)
  	send notify(e) to matchlist
  	fwdlist = match(e, routing)
  	send publish(e) to fwdlist - x;
  	
  upon receive subscribe(subscription s) from node x
  	if x is client then
  		add x to subscriptions;
  	else add(x,s) to routing;
  	send subscribe(s) to neighbours - x;
  ```

  在这里，每个节点维护一个邻居列表(neighbours)，该列表包含了该节点在代理网络中所有相连接的邻居，一个订阅列表(subscriptions)，该列表包含了由该节点位置服务的所有直接连接的订阅者，以及一个路由表。

* **汇聚：** 将事件集合看作是一个事件空间，并且将事件空间的责任划分到网络中的代理集合上。

* **广告：** 在有广告的系统中，通过与订阅传播类似的方式向订阅者传播广告，减少流量负担。

* **知情闲聊：** *informed gossip* ，比较高深了。

## 消息队列

消息队列提供的编程模型很简单，提供了在分布式系统中通过队列进行通信的一种方式，游戏是，生产者进程发送消息到特定队列，消费者进程从该队列中接受消息。通常支持三种接收方式：

* **阻塞接收：** 保持阻塞直至有合适的消息可用为止
* **非阻塞接收：** 轮询操作，检查队列的状态，返回可用消息，或者一个不可用的指示
* **通知操作：** 挡在相关队列中有一条消息可用时，会发出一个事件通知

消息队列可以是FIFO，也可以支持优先级概念，一条消息通常由目的地，与消息相关的元数据（包括消息的优先级、传递模式等字段）和消息体组成。

消息队列系统的一个重要特性是消息是持久的————也就是说，消息队列会无限期存储消息，直至它们被消费为止，并将消息提交到磁盘，以实现可靠传递。消息队列系统也支持一些其他功能，如事务性、消息转换、安全性等功能。

## 共享内存

分布式共享内存是一种读和写字节级别的操作，元组空间是以半截扣划数据的形式提供更高层的视角。此外，分布式共享内存可以通过地址进行访问，而元组空间是关联的，提供了一种内容可寻址的内存形式。

分布式共享内存与消息传递方法的对比：

* **提供的服务：** 消息传递模式下，变量必须在一个进程中编码，被传递后在接收进程中解码成其他变量。采用共享内存，相关进程直接共享变量，所以不需要编码，这样就不需要单独的通信操作。
* **持久化：** 通过DSM通信的进程可能在非重叠的生命周期上执行，进程可以在一个协定的内存位置放置数据，以便其他进程运行时查看数据。
* **效率：** 在消息传递中，所有的远程数据访问都是显式的，然而使用DSM，任何特定的读或者写或者更新都可能涉及、也可能不涉及底层运行时支持的通信。其涉及与否取决于数据以前是否被访问过以及在不同计算机上进程间的共享模式。



## Q & A

**1. 说明为什么间接通信适合在易变的环境。这些在多大的程度上归结于时间解耦、空间解耦或者两者的结合？**

使用时间解耦，通信双方不需要同时存在，在易变的环境中，发送者和接收者可以随时的进入和离开，使用空间解耦，系统开发者可以由很大的自由度去处理改变，发送者和接收者可以被替换、更新、复制和迁移。

**2. 消息被指向一个名称而非一个地址，而这个名称通过DNS解析，这样的系统是否表现出相同的间接水平？**

体现了通信的空间解耦，DNS服务器类似于一个中间件，处理了这一个转换，但是时间是耦合的，这个过程不能通过异步进行。

**3. 能否构建一个空间耦合但是时间解耦的系统，即消息是指向给定的接收者，但是接收者可以由独立于发送者的生命周期。比如电子邮件是否属于这种类型**

电子邮件属于这一类型，发送者知道接收者的身份，但是发送者和接收者不需要同时在线。此外，管道通信也属于这一类型。管道的发送方和接收方都是唯一的。接收方只有在发送方有数据时才会运行。*（管道不算，不能满足时间解耦的发送方、接收方不需要同时存在的需求）*

**4. 考虑一种排队RPC的通信范例，在移动环境中，通信的参与者可能断连一段时间，系统提供RPC范型，因此调用被指向一个给定的服务器（空间耦合），但是调用是通过中介（发送端的一个队列）被路由的，并被维护在队列中，直至接收者可用。这种算时间解耦么？**

可以这样看待这个问题，发送者和队列之间是耦合的，队列和接收者之间是耦合的（只有通信接通才能发送），但是发送者和接收者之间是时间解耦的，因为有队列作为数据缓冲区。

**5. 如果通信范型是异步的，那么是否是时间解耦的？**

不一定。异步的概念要求的是发送者发送一个消息后，直接执行接下来的步骤（不阻塞），因此不需要与接收者在同一时间通信。时间解耦要求的是发送者与接收者可以相互独立存在。异步不一定会时间解耦。

**6. 靠提供组通信服务上下文消息交换的例子，说明因果序和全排序的区别**

**因果序**考虑了消息之间的因果关系，如果在分布式系统中一个消息在另一个消息之前发生，那么传递相关消息的所有进程都要考虑这个因果关系。**全排序** 中一个消息在另一个消息之前被传递，那么胸痛的顺序将在所有进程上维持。因果序只考虑维持有必然先后顺序的消息的接受序，全排序严格保证所有消息的按序发送、接收。

**7. 考虑使用JGroups的样例，说明从可靠性和排序考虑，这类应用的需求是什么？**

需求是保证消息发送的可靠性，稳定性。

**8. 设计一个通知邮件服务，目的是代表多个订阅者存储通知，允许订阅者指定它们需要合适传递通知。阐述并不是时刻在线的订阅者如何利用你所描述的服务。服务在订阅者传递开启时如何处理订阅者崩溃。**

使用发布-订阅系统和队列缓冲的方式，每个订阅者注册后，在服务端注册事件，生成对应队列，如果有订阅者感兴趣的消息发布，将该消息存储进入相关队列中，如果订阅者与队列服务的通信联通，则发送相关消息推送至订阅者。处理订阅者崩溃通过重试断线重连机制，如果超出多少时间没有回馈，认为订阅者下线，取消订阅。

**9. 在发布-订阅系统中，解释如何使用一个组通信服务来实现基于渠道的方法？为什么对于基于内容方法的实现不是一个很好的策略**

基于渠道的方法，发送方和接收方通过一个已命名的渠道，完成消息的发送接收。基于内容方法的实现，效率会更低，需要服务去解析消息内容，实现一个复杂的事件通知系统。

**10. 以基于过滤的路由算法为起点，开发另一种算法，说明如何使用广告能对产生的消息流量有重大的优化？**

纯基于过滤的方法会由于定于的传播产生大量的网络流量，因为订阅的本质采用了洪泛方法对所有可能的发布者推送。而在使用了广告的系统中，通过与订阅传播类似的（事实上是对称的）方式向订阅者传播广告，这样流量负担可以减少。（为什么减少，没明白）

**11. 解释基于汇聚的路由算法的操作**

基于汇聚的路由使用了一种解释是将事件空间映射到分布式散列表，一个分布式散列表是一种网络覆盖形式，它将散列表分不到一个P2P网络的节点的集合，散列函数可以用于将事件与订阅映射到响应的管理这些订阅的汇聚节点上。

**12. 讨论两个可能的_EN(e)_ 和_SN(s)_ 实现，为什么对于一个给定的s与匹配的e，_EN(e)_ 和 _SN(s)_ 的交集必须是非空的？是否应用到你可能的实现**

_EN(e)_ 是与事件e相关联的节点，_SN(s)_ 是与订阅s相关联的节点。如果_EN(e)_ 与 _SN(s)_ 交集为空，那么e与s就不匹配，没有一个节点对该事件做了订阅处理，消息不需要传递。

**13. 解释消息队列内在的松耦合是怎样帮助企业应用集成的。这些在多大程度上归结于时间解耦、空间解耦或者两者结合**

消息队列能异步的有效拆解企业服务功能模块，是企业的功能模块构建耦合少、界限清晰、便于开发和运维。消息队列的时间解耦解决了应用之间的同步强耦合，消息队列的空间解耦解决了应用功能模块拆解的处理。

**14. 考虑用JMS编写的FireAlarm程序，如何扩展使得消费者只接受来自一个给定位置的报警**

使用客户端的过滤机制，对给定位置的报警做处理，其余报警只消费，不做额外处理。

**15. 解释在哪些方面，DSM适合或者不适合客户-服务器系统**

在提供的服务方面，DSM的对象数据是各进程共享，可能由于一个进程错误变更数据，导致所有相关进程失效。在异构性方面，DSM需要定义好不同计算机、操作系统对数据结构、字节表示的统一性处理。在持久性方面，DSM可以对所有数据持久化处理。在效率方面，使用DSM开发的并行程序，效率能做到和本地多进程类似的效率。

**16. 讨论消息传递和DSM，那个更适合容错的应用**

从上题克制，消息队列更适合容错要求高的系统应用，DSM共享内存模式下，数据、操作的错误会导致所有相关进程出错。

**17. 假设一个DSM系统以平台中立的方式在没有硬件支持的中间件内实现，你将如何处理异构计算机上的不同的数据表示问题？你的解决方案能否扩展到指针呢？**

可以考虑数据表示全部打平为ASCII文本格式，对二进制数据使用BASE64编码处理成文本格式。不能处理到指针，因为数据全部打平，每个字段的内存占用发生了改变，指针指向已经异常了。

**18. 如何使用元组空间实现等价的远程过程调用功能？按这种方式实现的远程过程交互有什么优点和缺点？**

进程通过访问同一元组空间实现共享数据：使用`write`操作将元组放置在元组空间中，使用`read`或者`take`操作从元组空间中读或者提取元组。`write`操作加入一个元组，但不影响元组空间中已存在的元组。`read`操作返回一个元组的值，但是不影响元组空间的内容，`take`操作返回一个元组，但是会删除。优点是如15题，缺点是`take`操作的易错性。

**19. 如何使用元组空间实现信号量**

不会

**20. 实现一个可复制的元组空间，解释该算法如何使用元组空间操作的语义去优化复制策略**

不会