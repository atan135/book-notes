## 坐标系统

将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，类似于流水线，在这个流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个**过渡** 坐标系的优点在于：在这些特定的坐标系统中，一些操作或者运算会更加方便和容易，比较重要的坐标系统有以下5个：

* 局部空间（Local Space）：或者成为物体空间（Object Space）
* 世界空间：World Space
* 观察空间：View Space
* 裁剪空间：Clip Space
* 屏幕空间：Screen Space

以上就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。

#### 1. 概述

将坐标从一个坐标系变换到另一个坐标系，需要用到几个变换矩阵，最重要的几个分别是 **模型**（model），**观察**（view），**投影**（projection）三个矩阵。我们的顶点起始于 **局部空间**（Local Space），在这里它被称为 **局部坐标**（Local Coordinate），在之后它会变为 **世界坐标**（World Coordinate），**观察坐标**（View Coordinate）， **裁剪坐标**（Clip Coordinate），并最后以 **屏幕坐标**（Screen Coordinate）的形式结束。

> 从观察空间到裁剪空间，裁剪坐标会被处理到-1.0到1.0的范围，并判断哪些顶点在屏幕上。
>
> 裁剪坐标到屏幕左边的变换，使用一个视口变换的过程，视口变换将位于-1.0到1.0范围的坐标转换为由 `glViewport` 定义的坐标范围，最终变换出来的坐标送到光栅器，转化为片段。

#### 2. 局部空间

局部空间是物体所在的坐标空间，即对象最开始所在的位置。模型的所有顶点都是在局部空间中，相对于模型来说都是局部的。

#### 3. 世界空间

世界空间中的坐标，是指顶点相对于游戏世界的坐标。如果希望将物体分散到世界上，这就是你希望物体变换到的空间，物体的坐标从局部变换到世界空间，该变换是由模型矩阵（model matrix）实现的。

模型矩阵是一个变换矩阵，它能通过对物体进行位移，缩放，旋转来将它置于它本来应该在的位置或者朝向。

#### 4. 观察空间

观察空间也被成为OpenGL的摄像机空间或者视觉空间，观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间是从摄像机的角度所观察到的空间。

这个变换通常是由一系列的位移和旋转的组合完成的，平移/旋转场景从而使得特定的对象被变换到摄像机的前方，这个组合在一起的变换通常存储在一个 **观察矩阵** 中，它被用来从世界坐标变换到观察空间。

#### 5. 裁剪空间

在一个顶点着色器运行的最后，OpenGL期望所有的坐标都会落在一个特定的范围，且这个范围之外的所有点都应该被 **裁剪** 掉，被裁剪掉的坐标就会被忽略，所以剩下的坐标就是屏幕的可见片段。这就是 **裁剪空间** 的由来。

为了将顶点坐标从观察空间变换到裁剪空间，需要定义一个 **投影矩阵**（Projection Matrix），它指定了一个范围的坐标，比如在每个维度是-1000到1000。投影矩阵然后会将在这个范围之内的坐标变换为标准化设备坐标的范围，所有在这个范围之外的坐标不会映射到这个范围所以会被裁剪掉。

> 如果只是图元（Primitive），例如三角形，的一部分超出了裁剪体积（Clipping Volume），则OpenGL会重新构建这个三角形为一个或者多个三角形让其能够适合这个裁减范围。

由投影矩阵创建的 **观察箱**（Viewing Box）被称为 **平截头体**（Frustum），每个出现在平截头体范围内的坐标最终都会出现在用户屏幕上。将特定范围的坐标转化到标准化设备坐标系的过程（而且很容易被映射到2D屏幕空间）被称为 **投影**。

一旦所有顶点变换到裁剪空间，最终的操作 **透视除法**（Perspective Division）将会执行，在这个过程中，位置向量的x，y，z分量会分别除以向量的齐次w分量，透视除法是将4D裁剪空间坐标换为3D标准化设备坐标的过程，这一步会在每个顶点着色器运行的最后被自动执行。

在这一阶段之后，最终的坐标会被映射到屏幕空间中，并被变换为片段。

投影矩阵有两种形式，分别是 **正射投影矩阵**（orthographic Projection Matrix）和 **透视投影矩阵**（Perspective Projection Matrix）。

**正射投影矩阵**：

```cpp
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100f);
```

这个会定义平截头的四边距离，以及近平面/远平面的距离。

**透视投影矩阵**：

将给定的平截头体映射到裁剪空间，并且会修改每个顶点的w值，从而使得离观察者越远的顶点坐标的w分量越大，被变换到裁剪空间的坐标都会在-w到w的范围之间（否则会被裁剪掉）。OpenGL要求所有课件的坐标都落在-1.0到1.0之间，作为顶点着色器的最后输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：
$$
out = \begin{pmatrix}x/w \\ y/w \\ z/w\end{pmatrix}
$$
这样距离观察者越远的顶点坐标就会越小，这也是w分量的重要作用，能够帮助我们进行透视投影，最后的结果坐标就是处于标准化设备空间中。创建透视投影矩阵的方法：

```cpp
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width / (float)height, 0.1f, 100.0f);
```

这里第一个参数定义了 `fov` 的值， 表示的是视野，并且设置了观察空间的大小，第二个参数设置了宽高比，第三、第四个参数定义的是平截头体的近平面和远平面。

> 当透视矩阵的近平面值设置太大时，OpenGL会将靠近摄像机的坐标都截取掉，会导致太靠近一个物体的时候，视线会直接穿过。

#### 6. 组合总结

一个顶点坐标的转换：
$$
V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}
$$
最后的顶点被赋值到着色器的 `gl_Position` 中，OpenGL会自动进行透视除法和裁剪。

顶点着色器拿到这个坐标后，然后对 **裁剪坐标** 执行 **透视除法** 从而将它变换到标准化设备坐标，OpenGL会使用 `glViewport` 内部的参数将标准化设备坐标映射到 **屏幕坐标**，每个坐标都关联了一个屏幕的点，这个过程就是 **视口变换**。

以下是项目代码：

```cpp
// 模型矩阵
glm::mat4 model = glm::mat4(1.0f);
model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f));
// 观察矩阵
glm::mat4 view = glm::mat4(1.0f);
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
// 投影矩阵
glm::mat4 projection = glm::mat4(1.0f);
projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f);

// 将这三个值传入shader中
myShader.SetMat("model", model);
myShader.SetMat("view", view);
myShader.SetMat("projection", projection);
```

对应的顶点shader为：

```glsl
#version 330 core
layout(location = 0) in vec3 aPos;
...
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0f);0.1
}
```

