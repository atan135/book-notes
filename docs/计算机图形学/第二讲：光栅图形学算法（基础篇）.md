光栅图形学算法是适应光栅显示器的算法，属于图形学算法的底层基础算法。

**光栅图形学算法的研究内容：**

* 直线段的扫描转换算法
* 多边形的描边算法和区域填充算法
* 裁剪算法
* 反走样算法
* 消隐算法

## 直线段的扫描算法

在像素平面上，线段方程为：

$$y = kx + b$$

则通过每个x的y值坐标可求出来，然后用$$y = [kx + b + 0.5]$$即向上取整得出

但是这样计算，需要使用一个乘法，使用算法可以取消掉这个乘积计算

**直线绘制的三种方法：**

* 数值微分法DDA：使用增量思想，每前进一个$$d x$$,$$d y = k$$ 这里需要考虑到$$|k| > 1$$ 的情况

* 中点画线法：使用直线的一般式方程

   $$a x + b y + c = 0$$，或者$$F(x,y) = 0$$ 

  有：

  

  $$d_{new}  = \begin{cases} d_{old} + A + B, d < 0 \\ d_{old} + A, d >= 0 \end{cases}$$    其中 $$d_0 = A + 0.5 B$$

  

  然后使用$$2 d$$ 代替 $$d$$ ，将浮点数取消掉，整个直线的点计算只需要使用整数加即可。

* Breshenham算法：

  1. 输入直线的两个初值点$$P _0 ( x _0, y _0)$$ 和$$P _1 ( x _1, y _1)$$ 
  2. 计算初始值$$\Delta x$$ 、$$\Delta y$$、$$e = -\Delta x$$ 、$$x = x _0$$、$$y = y _ 0$$
  3. 绘制点$$(x, y)$$
  4. $$e$$ 更新为$$e + 2\Delta y$$，判断$$e$$的符号。若$$e > 0$$ ，则$$(x, y)$$ 更新为$$(x+1,y+1)$$ ，同时将$$e$$ 更新为$$e - 2\Delta y$$ ;否则$$(x,y)$$ 更新为$$(x+1,y)$$
  5. 当直线没有画完时，重复步骤3和4，否则结束

**小结：**

1. 计算机科学的问题的核心是算法
2. 领会算法中蕴含的创新思想
3. 科学研究无止境，学术面前人人平等



## 多边形扫描转换和区域填充

多边形扫描转换和和区域填充是怎样在一个离散的像素集上表示一个连续的二维图形。

多边形有**顶点表示**和**点阵表示**两种形式表示。

**顶点表示**方式直观、几何意义强，占用内存小，但是没有明确指出哪些像素在多边形内，故不能直接用于面着色。

**点阵表示**用位于多边形内部的像素集合来刻画多边形。这种表示形式丢失了很多几何信息（如边界、顶点等），但是它是光栅显示系统显示时所需要的	表示形式。

​	

多边形分为三类：

**凸多边形：** 任意两个顶点的连线都在多边形内，就是凸多边形。

**凹多边形：** 任意两个顶点的连线，有不在多边形内的，那就是凹多边形。

**含内环的多边形：** 多边形内含有多边形。

**填充多边形的算法：**

* **X-扫描线算法：** 按扫描线顺序，计算扫描线和多边形的相交区间，再用要求的颜色填充这些区间的的像素。扫描线与多边形顶点的交点个数是根据顶点的线段另一端顶点的y值与扫描线y值比较得出是0，1，2个，这个算法因为需要求交，运算量极大。

  优化思路：

  1. 只对与扫描线有交点的边做求交运算
  2. 扫描线和下一条扫描线的交点有相关性，扫描线的连贯性
  3. 边和一条扫描线相交，很可能与下一条边相交，多边形的连贯性

  使用数据结构：

  1. **活性边表（AET）：** 将与当前扫描线相交的边按照交点x值坐标顺序存入一个链表中，相交的边称为活性边。
  2. **节点内容：** 一个结点在数据结构中可以使用一个struct表示，内有四个组成：$$x$$ :当前扫描线与边的交点坐标；$$\Delta x$$ : 从当前扫描线到下一条扫描线的x的增量；$$y_{max}$$ : 该边所交的最高扫描线的坐标值$$y_{max}$$ ,以及指向下一结点的指针。
  3. **新边表（NET）：** 用于存放多边形的边，生成规则是在一个二级链表，在每个扫描线处如果新增了交点边，那么把新边的链表接入扫描线链表中

  更新数据方式：

  1. 已有活性边是否需要剔除（活性边表的节点$$y_{max}$$值
  2. 如果不被剔除，那么需要对其节点数据使用增量做更新x值
  3. 在新边表内查看是否有新边成为活性边

* **边缘填充算法：** 按照任意顺序处理多边形的每一条边。在处理每一条边的时候，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补，多边形的所有边处理完后，填充即可。

* **栅栏填充算法：** 一条过多边形顶点且与扫描线垂直的直线，它把多边形分成两边，在处理每一条边与扫描线的交点的时候，将交点与栅栏之间的像素取补。

* **边界标志算法：** 帧缓冲器中对多边形的每条边进行直线扫描转换，即对多边形边界所经过的像素打上标志，然后再采用和扫描线算法类似的方法将位于多边形内部的各个区段着上对应的颜色。



## 区域填充

**区域填充**是指将区域内的一点（常称为种子点）赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。**区域**指已经表示成点阵形式的填充图形。

区域可以使用内点表示和边界表示两种表示形式。区域可分为**四连通区域**和**八连通区域**。

区域填充算法：

* 种子像素放入栈中，只要栈不空，重复下面三个步骤
* 栈顶元素出栈
* 将出栈元素置为填充色
* 按照左上右下顺序检查与出栈像素相邻的四个像素，若其中某个像素不在边界且未填充，则将该元素压入栈中

算法的缺点：

* 有些像素会入栈多次，降低了算法效率，且占用空间比较大
* 递归执行，效率不高

**改进：** 区域填充扫描线算法



## 反走样算法

产生图形走样的原因是光栅显示中像素的离散型产生的。比如直线的锯齿形、小物体的消失、动画中时隐时现产生闪烁。

用于减少和消除走样效果的技术，称为反走样技术。

两种反走样算法：

1. **非加权区域采样方法**

   根据物体的覆盖率计算像素的颜色，覆盖率指某个像素区域被物体覆盖的比例。

2. **加权区域采样方法**

   将直线看成是狭长的矩形，当线段与像素点相交时，根据相交区域与像素中心点的距离	决定其对像素亮度的贡献。然后将一个像素分为一个3*3的子像素集，计算加权后的像素点颜色。