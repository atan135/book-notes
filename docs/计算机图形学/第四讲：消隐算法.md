## 第四讲：消隐算法

当我们观察空间中任何一个不透明的物体，只能看到物体朝向我们的那些表面，其余的表面由于被物体所遮挡，所以看不到。

如果把可见和不可见的线都画出来，就会造成视觉的二义性。

要消除二义性，就必须在绘制的时候，消除被遮挡的不可见的线或者面，习惯上称作消除隐藏线和隐藏面，简称消隐。

**消隐的分类：**

按照消隐对象分类，可以分为：

* 线消隐
* 面消隐

按照消隐空间分类，分为：

* **物体空间的消隐算法：** 以场景中的物体为处理单元
* **图像空间的消隐算法：** 以屏幕窗口内的每一个像素为处理单元，这类算法是消隐算法的主流。
  * Z-Buffer算法
  * 扫描线算法
  * warnock消隐算法

**画家算法：** 原理是，一个场景中有很多物体的时候，先画远的物体，再画近的物体，这样，近处的物体自然就遮挡远处的物体了。但是只能适用于简单场景的消隐问题，而三维空间中物体相互遮挡的问题，就不能正确处理了

**Z缓冲区（Z-Buffer)算法：**

1973年犹他大学的Edwin Catmull独立开发的跟踪屏幕每个像素深度的算法Z-Buffer.

z缓冲器算法也叫做深度缓冲算法，属于图像空间的消隐算法，该算法有**帧缓冲器**和**深度缓冲器**，对应了两个数组：

​	$$\operatorname{Intensity}(x, y)$$ ------- 属性数组（帧缓冲器），用于存储图像空间每个可见像素的光强或者颜色

​	$$\operatorname{Depth}(x, y)$$ ------------深度数组（z-buffer)，存储图像空间每个可见像素的z坐标

**算法思想：**

 1. 先将Z缓冲器中各单元的初始值设置为最小值

	2. 当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值

	3. 如果大于原来的深度值，那么说明这个物体更靠近观察者，用它的颜色替换原来的颜色。

    **算法优点：**

    1. Z-Buffer算法简单，直观
    2. 是在像素级别处理，以近处物体像素颜色取代远处物体像素颜色，与计算先后顺序无关，有利于硬件实现
    3. 在内存容量不需要考虑的时候，该算法的实现很方便

    **算法缺点：**

    1. 内存占用空间大
    2. 没有利用图形的相关性、连续性，这是Z-Buffer算法的严重缺陷
    3. 该算法是像素级别的处理算法，效率低

    

    

    