## 第四讲：消隐算法

当我们观察空间中任何一个不透明的物体，只能看到物体朝向我们的那些表面，其余的表面由于被物体所遮挡，所以看不到。

如果把可见和不可见的线都画出来，就会造成视觉的二义性。

要消除二义性，就必须在绘制的时候，消除被遮挡的不可见的线或者面，习惯上称作消除隐藏线和隐藏面，简称消隐。

**消隐的分类：**

按照消隐对象分类，可以分为：

* 线消隐
* 面消隐

按照消隐空间分类，分为：

* **物体空间的消隐算法：** 以场景中的物体为处理单元
* **图像空间的消隐算法：** 以屏幕窗口内的每一个像素为处理单元，这类算法是消隐算法的主流。
  * Z-Buffer算法
  * 扫描线算法
  * warnock消隐算法

**画家算法：** 原理是，一个场景中有很多物体的时候，先画远的物体，再画近的物体，这样，近处的物体自然就遮挡远处的物体了。但是只能适用于简单场景的消隐问题，而三维空间中物体相互遮挡的问题，就不能正确处理了

**Z缓冲区（Z-Buffer)算法：**

1973年犹他大学的Edwin Catmull独立开发的跟踪屏幕每个像素深度的算法Z-Buffer.

z缓冲器算法也叫做深度缓冲算法，属于图像空间的消隐算法，该算法有**帧缓冲器**和**深度缓冲器**，对应了两个数组：

​	$$\operatorname{Intensity}(x, y)$$ ------- 属性数组（帧缓冲器），用于存储图像空间每个可见像素的光强或者颜色

​	$$\operatorname{Depth}(x, y)$$ ------------深度数组（z-buffer)，存储图像空间每个可见像素的z坐标

**算法思想：**

 1. 先将Z缓冲器中各单元的初始值设置为最小值

 2. 当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值

 3. 如果大于原来的深度值，那么说明这个物体更靠近观察者，用它的颜色替换原来的颜色。

**算法优点：**

 1. Z-Buffer算法简单，直观
 2. 是在像素级别处理，以近处物体像素颜色取代远处物体像素颜色，与计算先后顺序无关，有利于硬件实现
 3. 在内存容量不需要考虑的时候，该算法的实现很方便

**算法缺点：**

      1. 内存占用空间大
      2. 没有利用图形的相关性、连续性，这是Z-Buffer算法的严重缺陷
      3. 该算法是像素级别的处理算法，效率低

**点与多边形的包含性检测：**

* **射线法**： 由被测点P向$$y = -\infty$$ 方向做一条射线，如果交点有奇数个，那么被测点在多边形内部。如果涉嫌经过多边形顶点，那么如果边在射线的左边，计算交点，如果在边在射线的右侧，则不计算交点。缺点是计算量大，不稳定。
* **弧长法：** 对点P做单位圆，将多边形每条边投影到单位元上，规定逆时针为正，顺时针为负，计算多边形的投影的代数和，如果代数和为0，点P在多边形外面，代数和为$$2\pi$$ ，点P在多边形内部，代数和为$$\pi$$ ，点P在多边形的边上。
* **以定点符号为基础的弧长累加法：** 根据顶点所在点P的坐标系的象限，象限间的顶点累加只计算符号。

   

**区间扫描线算法：** 速度最快的消隐算法之一

把扫描线与多边形的交点求出来，那么交点之间的像素的颜色是一样的。

**Warnock消隐算法：** 也称为区域子分割算法

是图像空间中非常经典的算法，重要性不在于它的效率比别的算法高，而是在于采用了分而治之的思想，利用了堆栈的数据结构。将物体投影到全屏幕上，然后递归分割窗口，直至窗口内目标足够简单，能够直接显示为止。

分为几种情况：

* 窗口只包含一个窗口
* 窗口和一个多边形相交，且窗口内无其他多边形
* 窗口为一个多边形包围
* 窗口与一个多边形相分离

**算法思想：** 如果窗口没有物体，显示背景色，如果有单个物体，显示单个物体颜色，如果含有两个以上的面，则将窗口等分为四个窗口。递归计算

```
stack A -> empty
Rect R -> 初始窗口
A.push(R)
while(!A.empty()){
    Rect t = A.pop()
    if 窗口t 只包含一个像素{
    	Draw(t, averagecolor)
    }
    else if 窗口t 没有物体{
    	Draw(t, backgroundcolor)
    }
    else if 窗口t 只有单个物体{
    	Draw(t, targetcolor)
    }else{
        A.push(Rect((0,0),(x/2,y/2)))
        A.push(Rect((x/2,0),(x,y/2)))
        A.push(Rect((0,y/2),(x/2,y)))
        A.push(Rect((x/2,y/2),(x,y)))
    }
}
```



**光栅扫描算法小结：**

1. **直线段的扫描转换算法**

   这是一维图形的显示基础，

   1. DDA算法：使用直线的斜截式方程，利用增量思想，将一个乘法和一个加法，转化为一个加法
   2. 中点画线法：使用直线的一般式方程，优点是使用的整数加法
   3. Bresenham算法：优点是还能用于其他二次曲线

2. **多边形的扫描转换和区域填充算法**

   如何把边界表示的多边形表示成为由像素逐点描述的多边形，这是二维图形显示的基础

   有四个步骤：求交、排序、配对、着色。这里引进一个新的思想---图形的连贯性，手段是利用增量算法和特殊的数据结构（多边形y表，边y表，活化多边形表，活化边表），2个指针数组和两个指针链表

3. **直线和多边形裁剪**

   两个经典算法：cohen-Sutherland算法，l梁-barsky算法

   cohen-Sutherland算法：通过编码，通过编码的与或运算，判断直线段是在窗口内还是外

   梁算法：直线方程使用参数方程形式，把被裁剪的直线段看成是有方向的线段，把窗口的四条边分为入边和出边

4. **走样和反走样**

   用离散量表示连续量，有限的表示无限的，自然会有失真，这种现象就叫做走样

   反走样的三个方法：

   * 提高分辨率
   * 区域采样算法：将有颜色的过渡区域变得平滑一点
   * 加权区域算法：

5. **消隐**

   在绘制场景时，消除被遮挡的不可见面或者线，称作消隐

   消隐算法按照消隐空间分类：

   1. 物体空间：以场景中的物体为为处理单元
   2. 图像空间：以屏幕中的像素点为处理空间
      * 经典的Z-Buffer算法：单变量的z-buffer，射线法，弧长法，改良符号的弧长法
      * 区间扫描算法：将逐点处理变成逐段处理
      * Warnock消隐算法：分而治之，将物体投影到全屏幕中，然后分而治之处理